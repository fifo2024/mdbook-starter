<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>自定义hook - React Hooks学习</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded "><a href="00_preface.html"><strong aria-hidden="true">1.</strong> 前言</a></li><li class="chapter-item expanded "><a href="01_react_hooks_brief.html"><strong aria-hidden="true">2.</strong> React Hooks简介</a></li><li class="chapter-item expanded "><a href="02_useState_base.html"><strong aria-hidden="true">3.</strong> useState基础用法</a></li><li class="chapter-item expanded "><a href="03_useState_advanced.html"><strong aria-hidden="true">4.</strong> useState高级用法</a></li><li class="chapter-item expanded "><a href="04_useEffect_base.html"><strong aria-hidden="true">5.</strong> useEffect基础用法</a></li><li class="chapter-item expanded "><a href="05_useEffect_advanced.html"><strong aria-hidden="true">6.</strong> useEffect高级用法</a></li><li class="chapter-item expanded "><a href="06_useContext_base.html"><strong aria-hidden="true">7.</strong> useContext基础用法</a></li><li class="chapter-item expanded "><a href="07_useContext_advanced.html"><strong aria-hidden="true">8.</strong> useContext高级用法</a></li><li class="chapter-item expanded "><a href="08_useReducer_base.html"><strong aria-hidden="true">9.</strong> useReducer基础用法</a></li><li class="chapter-item expanded "><a href="09_useReducer_advanced.html"><strong aria-hidden="true">10.</strong> useReducer高级用法</a></li><li class="chapter-item expanded "><a href="10_useCallback_base.html"><strong aria-hidden="true">11.</strong> useCallback基础用法</a></li><li class="chapter-item expanded "><a href="11_useMemo_base.html"><strong aria-hidden="true">12.</strong> useMemo基础用法</a></li><li class="chapter-item expanded "><a href="12_useRef_base.html"><strong aria-hidden="true">13.</strong> useRef基础用法</a></li><li class="chapter-item expanded "><a href="13_useImperativeHandle_base.html"><strong aria-hidden="true">14.</strong> useImperativeHandle基础用法</a></li><li class="chapter-item expanded "><a href="14_useLayoutEffect_base.html"><strong aria-hidden="true">15.</strong> useLayoutEffect基础用法</a></li><li class="chapter-item expanded "><a href="15_useDebugValue_base.html"><strong aria-hidden="true">16.</strong> useDebugValue基础用法</a></li><li class="chapter-item expanded "><a href="16_Custom_hook.html" class="active"><strong aria-hidden="true">17.</strong> 自定义hook</a></li><li class="chapter-item expanded "><a href="17_hooks_summary.html"><strong aria-hidden="true">18.</strong> React Hook 总结</a></li><li class="chapter-item expanded "><a href="18_hooks_echarts.html"><strong aria-hidden="true">19.</strong> 示例：React使用Echarts所用到的hooks</a></li><li class="chapter-item expanded "><a href="attachment_01_base.html"><strong aria-hidden="true">20.</strong> 附01：React基础知识</a></li><li class="chapter-item expanded "><a href="attachment_02_extend.html"><strong aria-hidden="true">21.</strong> 附02：React扩展阅读</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">React Hooks学习</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="16-自定义hook"><a class="header" href="#16-自定义hook">16 自定义hook</a></h1>
<h2 id="自定义hook概念解释"><a class="header" href="#自定义hook概念解释">自定义hook概念解释</a></h2>
<p>像useState、useEffect、useContext、useReducer、useCallback、useMemo、useRef、useImperativeHandle、useLayoutEffect、useDebugValue这10个hook是react默认自带的hook，而所谓自定义hook就是由我们自己编写的hook。</p>
<p>所谓自定义hook就是把原来写在函数组件内的hook相关代码抽离出来，单独定义成一个函数，而这个抽离出来的hook函数就称之为“自定义hook钩子函数”，简称“自定义hook”。</p>
<h2 id="自定义hook是来解决什么问题的"><a class="header" href="#自定义hook是来解决什么问题的">自定义hook是来解决什么问题的？</a></h2>
<p>答：自定义hook是将原来在组件中编写的相关hook代码抽离出组件，让hook相关代码独立存在，达到优化代码结构、相关hook代码可以重复使用的目的。</p>
<p>补充说明：<br />
1、如果你在别人的项目代码中，发现除了react默认自带的那10个hook以外，出现了 useXxx() 这样的看着像hook的函数，可以肯定那些就是自定义的hook。<br />
2、随着react新版本发布，可能会出现更多新的、默认自带的hook。</p>
<h2 id="自定义hook基本用法"><a class="header" href="#自定义hook基本用法">自定义hook基本用法</a></h2>
<p>首先我们知道hook只能用在函数组件中，而函数组件本身是一个稍微特殊的函数，尽管稍微特殊但毕竟他也遵循一般函数的使用规律。 所谓“把原来写在函数组件内的hook相关代码抽离出来，单独定义成一个函数” 本质上就是把函数内部定义的变量或方法拿出来，放到函数外面单独定义成一个函数。</p>
<p>这个抽离出来新定义的函数，遵循JS默认的函数用法，即函数参数可以任意设定，返回值也可以是任意内容。</p>
<p>请注意：react规定所有的自定义hook函数命名时必须使用 useXxx 这种形式。</p>
<p>举一个最简单的例子：假设我们有一个组件，组件内部有一个count的变量，我们的代码之前是这样的：</p>
<pre><code>import React,{useState} from 'react'
function CurrentComponent() {
  const [count,setCount] = useState(0);//请注意这行代码，就是我们要即将抽离出去的hook
  return (
    &lt;div&gt;
        {count}
        &lt;button onClick={() =&gt; setCount(count+1)}&gt;add +1&lt;/button&gt;
    &lt;/div&gt;
  )
}
export default CurrentComponent
</code></pre>
<p>在上面这个组件中，通过 const [count,setCount] = useState(0) 定义了组件内的变量count和修改count的方法。那我们现在将这行相关的hook抽离出函数组件。我们计划把抽离出来的、和count相关的函数，命名为useCount，修改后的代码如下：</p>
<pre><code>//useState.js
import {useState} from 'react'；
function useCount(initialValue){

  //依然使用 useState 创建countcount和setCount
  //并且将参数initialValue的值赋予给count作为默认值
  //将创建好的count和setCount作为函数返回值 return 出去

  const [count,setCount] = useState(initialValue);
  return [count,setCount];
}
export default useCount;

//CurrentComponent.js
import React from 'react'
import useCount from './useCount';//引入useCount
function CurrentComponent() {
  const [count,setCount] = useCount(0);//请注意这里使用的是useCount，而不是useState
  return (
    &lt;div&gt;
        {count}
        &lt;button onClick={() =&gt; setCount(count+1)}&gt;add +1&lt;/button&gt;
    &lt;/div&gt;
  )
}
export default CurrentComponent
</code></pre>
<h5 id="代码分析"><a class="header" href="#代码分析">代码分析：</a></h5>
<p>1、我们将原本组件内定义的count相关代码抽离出组件，单独定义一个 useCount 函数。<br />
2、组件需要使用 useCount，只需先引入useCount，然后把 useCount 当成普通函数使用就好了。<br />
3、useCount就是我们自定义的hook。</p>
<p>注意：一般自定义hook顶部是不需要引入React的，只需要引入使用到的 hook 函数即可。<br />
例如上面 useCount 顶部，我们写的是 import {useState} from 'react' 而不是 import React,{useState} from 'react'；</p>
<p>上面举例中的useCount非常简单，内部并没有过多逻辑，在实际开发中自定义hook内部肯定要有比较复杂的逻辑。</p>
<p>由于是单独定义的，所以自定义hook可以同时被多个组件引入和使用，达到代码复用的目的。</p>
<p>划重点，在实际项目中，通常自定义hook返回值有3种表现形式：<br />
1、不带返回值的函数<br />
2、带普通返回值的函数<br />
3、带特殊结构返回值的函数</p>
<p>以上3种不同返回值各有各的适用场景，下面就以实际示例来逐一说明。</p>
<h2 id="不带返回值的自定义hook使用示例"><a class="header" href="#不带返回值的自定义hook使用示例">不带返回值的自定义hook使用示例：</a></h2>
<p>举例：若父组件内有多个子组件，每个子组件内部都有不同的业务代码，但是所有子组件有一个相同的功能，就是当自身内部变量value发生变化时，将网页标题改为变量value的值。</p>
<p>首先我们知道修改网页标题是在组件内部的useEffect()函数中修改，那结合上面的使用场景，我们可以将useEffect()单独抽离出来，作为一个自定义hook，命名为 useDocumentTitle，让所有子组件都复用这个useDocumentTitle。</p>
<p>useDocumentTitle 代码如下：</p>
<pre><code>import {useEffect} from 'react'
function useDocumentTitle(value) {
  useEffect(() =&gt; {
    document.title = value;
  },[value]);
}
export default useDocumentTitle;
</code></pre>
<p>假设我们其中一个子组件的功能为：<br />
1、有1个number类型的变量count<br />
2、有1个按钮，点击按钮后将count修改为一个随机数字<br />
3、当组件重新渲染完成后，将网页标题修改为count的值</p>
<p>子组件代码为：</p>
<pre><code>import React,{useState} from 'react'
import useDocumentTitle from './useDocumentTitle';
function ChildComponent() {
  const [count,setCount] = useState(0);
  useDocumentTitle(count);//把内部变量count传给useDocumentTitle，既作为网页标题内容，同时也作为useEffect的变量依赖
  return (
    &lt;div&gt;
        &lt;button onClick={() =&gt; setCount(Math.floor(Math.random()*1000))}&gt;click me&lt;/button&gt;
    &lt;/div&gt;
  )
}
export default ChildComponent
</code></pre>
<p>其他子组件也使用useDocumentTitle，这样我们便将原本每个子组件都需要编写的useEffect改为统一的useDocumentTitle，实现了代码复用。</p>
<p>应用场景小总结：<br />
在这个示例中，useDocumentTitle函数并没有任何返回值，子组件使用useDocumentTitle时就好像原本那段useEffect代码本身就定义在那里似的。</p>
<h2 id="带普通返回值的自定义hook使用示例"><a class="header" href="#带普通返回值的自定义hook使用示例">带普通返回值的自定义hook使用示例：</a></h2>
<p>在本章最开始讲解“自定义hook基本用法”时，所举的useCount例子非常简单，这次我们将对useCount进行功能上的扩展。</p>
<p>原本useCount只是定义了count和setCount，这次所谓的功能扩展，就是将setCount改为其他几种修改count的函数。<br />
例如：<br />
1、添加 add()<br />
2、减去 sub()<br />
3、相乘 mul()<br />
4、恢复初始值 reset()</p>
<p>修改后的useCount代码为：</p>
<pre><code>import {useState} from 'react'
function useCount(initialValue){
  const [count,setCount] = useState(initialValue);
  const add = param =&gt; {setCount(prev =&gt; prev + param);}
  const sub = param =&gt; {setCount(prev =&gt; prev - param);}
  const mul = param =&gt; {setCount(prev =&gt; prev * param);}
  const reset = () =&gt; {setCount(() =&gt; initialValue);}
  return [count,add,sub,mul,reset]; //将count和定义的4个方法作为返回值 return 出去
}
export default useCount;
</code></pre>
<p>请注意：为了避免4个修改函数中得到的是旧的count，所以我们采用的是 setCount(prev =&gt; xxxxx) 这种修改方式，而不是直接使用 setCount(count xxx)。</p>
<p>CurrentComponent组件想使用useCount，代码为：</p>
<pre><code>import React from 'react'
import useCount from './useCount'

function CurrentComponent() {
  const [count,add,sub,mul,reset] = useCount(0); //使用useCount，并解构useCount的返回值
  return (
    &lt;div&gt;
        {count}
        &lt;button onClick={() =&gt; {add(1)}}&gt;+ 1&lt;/button&gt;
        &lt;button onClick={() =&gt; {sub(1)}}&gt;- 1&lt;/button&gt;
        &lt;button onClick={() =&gt; {mul(2)}}&gt;* 2&lt;/button&gt;
        &lt;button onClick={() =&gt; {reset()}}&gt;reset&lt;/button&gt;
    &lt;/div&gt;
  )
}
export default CurrentComponent
</code></pre>
<p>对于上面这个效果，你是否觉得眼熟？  没错，在讲解useReducer时，就使用useReducer实现了类似的一个效果。  只不过这次是为了讲解自定义hook，而那次是讲解如何使用useReducer替代useState实现复杂的业务。</p>
<p>应用场景小总结：<br />
1、我们可以在自定义hook中编写相关业务逻辑函数(方法)，并通过返回值的形式 return 出去，供其他组件调用。</p>
<h2 id="带特殊结构返回值的自定义hook使用示例"><a class="header" href="#带特殊结构返回值的自定义hook使用示例">带特殊结构返回值的自定义hook使用示例：</a></h2>
<p>上一个代码示例讲解了“带普通返回值”的自定义hook，那这次要讲的“带特殊结构返回值”的自定义hook究竟差别在哪里？</p>
<p>“带特殊结构返回值”中的特殊是指？<br />
答：我们把组件需要用到的多项属性设置，合并为一个对象 并 return 出去，供组件使用。</p>
<p>还是以示例来讲解会更容易理解，假设我们有一个登录组件，功能为：<br />
1、有一个用户名输入框<br />
2、有一个密码输入框<br />
3、有一个提交按钮</p>
<p>补充说明，为了简化代码，我们并不做真正的登录验证，点击提交按钮后：<br />
1、仅仅是alert一下用户名和密码，即表示登录<br />
2、同时清除用户名和密码输入框里的内容</p>
<p>需求分析：<br />
1、每个输入框都是一个&lt;input&gt;，都需要绑定一个变量，都需要设置onChange事件<br />
2、每一个输入框都需要清空内容</p>
<p>我们将定义一个自定义hook，命名为useInput，useInput来实现这2个输入框共有的业务逻辑。</p>
<p>useInput的代码为：</p>
<pre><code>import {useState} from 'react'
function useInput(initialValue) {
  const [value,setValue] = useState(initialValue); //定义输入框对应的值value
  //定义reset函数，用来重置输入框
  const reset = () =&gt; {
    setValue(initialValue);
  }
  //定义一个 bind 对象，该对象有 value 和 onChange 2个属性
  const bind = {
    value,
    onChange: eve =&gt; {
        setValue(eve.target.value)
    }
  }
  return [value,reset,bind];//将输入框的值、重置输入框函数、定义的bind对象作为返回值 return 出去
}
export default useInput
</code></pre>
<p>请注意：在useInput中，返回值 value、reset 我们很容易理解，但是 bind 是来做什么的？<br />
答：这个 bind 就是我们前面提到的“带特殊结构返回值”，bind对象本身结构由2个属性value和onChange组成。<br />
至于 bind 怎么用，很快揭晓。</p>
<p>登录组件LoginForm的代码为：</p>
<pre><code>import React from 'react'
import useInput from './useInput';
function LoginForm() {
  const [usename,resetUsename,bindUsename] = useInput(''); //定义用户名输入框相关的变量
  const [password,resetPassword,bindPassword] = useInput(''); //定义密码输入框相关的变量

  const submitHandle = (eve) =&gt; {
    eve.preventDefault(); //阻止form真正提交
    alert(`usename:${usename}\rpassword:${password}`); //通过alert，弹出用户名和密码的值
    resetUsename(); //重置用户名输入框
    resetPassword(); //重置密码输入框
  }

  //请特别留意用户名和密码输入框中的 {...bindUsename}和{...bindPassword}
  return (
    &lt;form onSubmit={submitHandle}&gt;
        &lt;label&gt;usename:&lt;/label&gt;
        &lt;input type='text' {...bindUsename} /&gt;
        &lt;label&gt;password:&lt;/label&gt;
        &lt;input type='password' {...bindPassword} /&gt;
        &lt;input type='submit' value='login' /&gt;
    &lt;/form&gt;
  )
}
export default LoginForm;
</code></pre>
<p>对于获取输入框的值、以及调用输入框对应的reset()函数，相信你很容易理解。</p>
<p>下面对 {...bindUsename} 和 {...bindPassword} 做进一步说明：<br />
1、首先我们知道 {...obj} 这种在原生JS中，相当于把obj对象进行解构，然后得到一个浅拷贝的新对象。<br />
2、但是在上面的代码中并不是这个意思，千万不要被迷惑。 在JSX中的某组件，如果要添加某属性，格式为 xxx={xxx}。</p>
<p>例如常见的给一个输入框绑定某变量，同时添加onChange事件，一般写法为：</p>
<pre><code>&lt;input type='text' value={xx} onChange={xxxx} /&gt;
</code></pre>
<p>而我们本次代码中，采用的是：</p>
<pre><code>&lt;input type='text' {...bindUsename} /&gt;
&lt;input type='password' {...bindPassword} /&gt;
</code></pre>
<p>这里面的 {...bindUsename}  {...bindPassword} 其实相当于把 bindUsename 和 bindPassword 进行了解构，就好像直接写在这里似的。</p>
<p>如果&lt;input&gt;中有非常多相同的属性，那么把这些相同属性提炼到 useInput 的 bind 中，这样可以简化组件里的代码。</p>
<p>应用场景小总结：<br />
1、在自定义hook中，将组件需要的多项属性合并成一个对象，供组件属性解构使用，会简化组件代码，提高代码复用率。</p>
<p>相信通过上面3个示例，对自定义hook的返回值不同形式的演示，举一反三，会帮助你灵活的编写自定义hook。</p>
<hr />
<p>至此，关于自定义hook已经讲完。</p>
<p>我们对之前所有学过的hook进行一次小总结。</p>
<p>欢迎进入下一章节：<a href="https://github.com/puxiao/react-hook-tutorial/blob/master/17%20React%20Hook%20%E6%80%BB%E7%BB%93.md">React Hook 总结</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="15_useDebugValue_base.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="17_hooks_summary.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="15_useDebugValue_base.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="17_hooks_summary.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>



        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
